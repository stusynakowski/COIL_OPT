#!/usr/bin/env python
"""
Interactive 3D visualization of coils and plasma surface using Plotly.
Loads VTK/VTU files generated by example_1_case.py.
"""

import numpy as np
import plotly.graph_objects as go
from pathlib import Path
import meshio
import sys

# === Output directory from example_1_case.py ===
OUT_DIR = Path("./output/")

# Which stage to visualize: "init" or "opt"
STAGE = "opt_15"  # Change to "init" to see the initial configuration


def discover_files(out_dir, stage):
    """List all available files in the output directory matching the stage."""
    print(f"\n=== Files in {out_dir} ===")
    if not out_dir.exists():
        print(f"  ERROR: Directory {out_dir} does not exist!")
        return
    all_files = sorted(out_dir.iterdir())
    for f in all_files:
        print(f"  {f.name}")
    print()

    # Find curve files matching stage
    curve_candidates = sorted(out_dir.glob(f"curves_{stage}*"))
    print(f"Curve files matching 'curves_{stage}*':")
    for f in curve_candidates:
        print(f"  {f}")

    surf_candidates = sorted(out_dir.glob(f"surf_{stage}*"))
    print(f"Surface files matching 'surf_{stage}*':")
    for f in surf_candidates:
        print(f"  {f}")
    print()

    return curve_candidates, surf_candidates


def find_file(out_dir, basename):
    """Try multiple extensions to find a VTK file."""
    for ext in [".vtu", ".vtk", ".vts", ""]:
        candidate = out_dir / f"{basename}{ext}"
        if candidate.exists():
            return candidate
    return None


def plot_curves_from_vtu(fig, filepath, name_prefix="Coil", colors=None, line_width=5):
    """Plot coils from a single VTU/VTK file containing multiple coils as separate cells."""
    if colors is None:
        colors = [
            "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728",
            "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
            "#bcbd22", "#17becf", "#aec7e8", "#ffbb78",
            "#98df8a", "#ff9896", "#c5b0d5", "#c49c94",
        ]

    mesh = meshio.read(str(filepath))
    points = mesh.points

    coil_idx = 0
    for cell_block in mesh.cells:
        if cell_block.type == "line":
            segments = cell_block.data  # shape (n_segments, 2)
            current_chain = [segments[0][0], segments[0][1]]

            for seg in segments[1:]:
                if seg[0] == current_chain[-1]:
                    current_chain.append(seg[1])
                else:
                    # New coil starts
                    pts = points[current_chain]
                    pts = np.concatenate([pts, pts[:1]], axis=0)
                    color = colors[coil_idx % len(colors)]
                    fig.add_trace(
                        go.Scatter3d(
                            x=pts[:, 0], y=pts[:, 1], z=pts[:, 2],
                            mode="lines",
                            line=dict(width=line_width, color=color),
                            name=f"{name_prefix} {coil_idx + 1}",
                        )
                    )
                    coil_idx += 1
                    current_chain = [seg[0], seg[1]]

            # Last coil
            pts = points[current_chain]
            pts = np.concatenate([pts, pts[:1]], axis=0)
            color = colors[coil_idx % len(colors)]
            fig.add_trace(
                go.Scatter3d(
                    x=pts[:, 0], y=pts[:, 1], z=pts[:, 2],
                    mode="lines",
                    line=dict(width=line_width, color=color),
                    name=f"{name_prefix} {coil_idx + 1}",
                )
            )
            coil_idx += 1

    return coil_idx


def plot_surface_from_vtu(fig, filepath):
    """Plot the plasma surface from a VTK file with B·n coloring."""
    mesh = meshio.read(str(filepath))
    points = mesh.points

    # Extract B_N data if available
    b_n = None
    # Check point_data
    if mesh.point_data:
        for key in mesh.point_data:
            if "B_N" in key or "b_n" in key.lower():
                b_n = mesh.point_data[key].flatten()
                print(f"  Found point data '{key}' with {len(b_n)} values")
                break
    # Check cell_data
    if b_n is None and mesh.cell_data:
        for key in mesh.cell_data:
            if "B_N" in key or "b_n" in key.lower():
                b_n_list = mesh.cell_data[key]
                b_n = np.concatenate([arr.flatten() for arr in b_n_list])
                print(f"  Found cell data '{key}' with {len(b_n)} values")
                break

    # Print available data keys for debugging
    if mesh.point_data:
        print(f"  Available point_data keys: {list(mesh.point_data.keys())}")
    if mesh.cell_data:
        print(f"  Available cell_data keys: {list(mesh.cell_data.keys())}")
    print(f"  Cell types: {[cb.type for cb in mesh.cells]}")

    # Extract faces for plotting
    triangles = []
    for cell_block in mesh.cells:
        if cell_block.type == "triangle":
            triangles.append(cell_block.data)
        elif cell_block.type == "quad":
            quads = cell_block.data
            tri1 = quads[:, [0, 1, 2]]
            tri2 = quads[:, [0, 2, 3]]
            triangles.append(tri1)
            triangles.append(tri2)

    # For structured grids (.vts), meshio may give "hexahedron" or "quad" cells.
    # If no triangles/quads found, try to build a surface mesh from the point grid.
    if not triangles:
        print(f"  No triangle/quad cells found. Attempting structured grid reconstruction...")
        # Try to infer grid dimensions from the points
        # For a structured surface, we can triangulate based on known nphi x ntheta
        n_points = len(points)
        # Try common dimensions
        for nphi in [64, 128, 32, 48, 96, 256]:
            if n_points % nphi == 0:
                ntheta = n_points // nphi
                if ntheta > 1:
                    print(f"  Guessing grid: {nphi} x {ntheta}")
                    tris = []
                    for i in range(nphi - 1):
                        for j in range(ntheta - 1):
                            idx00 = i * ntheta + j
                            idx10 = (i + 1) * ntheta + j
                            idx01 = i * ntheta + (j + 1)
                            idx11 = (i + 1) * ntheta + (j + 1)
                            tris.append([idx00, idx10, idx11])
                            tris.append([idx00, idx11, idx01])
                    triangles.append(np.array(tris))
                    break

    if not triangles:
        print(f"  Warning: Could not extract surface mesh from {filepath}")
        return

    all_triangles = np.concatenate(triangles, axis=0)

    # Build intensity per vertex
    if b_n is not None and len(b_n) == len(points):
        intensity = b_n
        colorscale = "RdBu"
        cmid = 0
        cmin = -np.max(np.abs(b_n))
        cmax = np.max(np.abs(b_n))
        colorbar = dict(title="B·n")
    else:
        intensity = None
        colorscale = None
        cmid = None
        cmin = None
        cmax = None
        colorbar = None
        if b_n is not None:
            print(f"  Warning: B_N length ({len(b_n)}) != points ({len(points)}), skipping coloring")

    fig.add_trace(
        go.Mesh3d(
            x=points[:, 0],
            y=points[:, 1],
            z=points[:, 2],
            i=all_triangles[:, 0],
            j=all_triangles[:, 1],
            k=all_triangles[:, 2],
            intensity=intensity,
            colorscale=colorscale,
            cmid=cmid,
            cmin=cmin,
            cmax=cmax,
            colorbar=colorbar,
            opacity=0.45,
            name="Plasma surface",
            showlegend=True,
        )
    )


# === Discover available files ===
curve_files, surf_files = discover_files(OUT_DIR, STAGE)

# === Build the figure ===
fig = go.Figure()

# --- Plot the main (unperturbed) coils ---
main_curves_file = find_file(OUT_DIR, f"curves_{STAGE}")
if main_curves_file is not None:
    print(f"Loading coils from {main_curves_file}")
    n_coils = plot_curves_from_vtu(fig, main_curves_file, name_prefix="Coil", line_width=6)
    print(f"  Loaded {n_coils} coils")
else:
    print(f"Warning: No curves file found for stage '{STAGE}'.")
    print(f"Available curve files in {OUT_DIR}:")
    for f in sorted(OUT_DIR.glob("curves_*")):
        print(f"  {f.name}")
    sys.exit(1)

# --- Optionally overlay perturbed coil samples ---
SHOW_PERTURBED = True
MAX_PERTURBED_SAMPLES = 3

if SHOW_PERTURBED:
    # Try multiple extensions for perturbed files
    pert_files = []
    for ext in [".vtu", ".vtk"]:
        pert_files.extend(sorted(OUT_DIR.glob(f"curves_{STAGE}_*{ext}")))
    pert_files = sorted(set(pert_files))

    for idx, pf in enumerate(pert_files[:MAX_PERTURBED_SAMPLES]):
        print(f"Loading perturbed coils from {pf}")
        plot_curves_from_vtu(
            fig, pf,
            name_prefix=f"Pert {idx}",
            line_width=2,
            colors=["rgba(150,150,150,0.3)"] * 16,
        )

# --- Plot the plasma surface ---
surf_file = find_file(OUT_DIR, f"surf_{STAGE}")
if surf_file is not None:
    print(f"Loading surface from {surf_file}")
    plot_surface_from_vtu(fig, surf_file)
else:
    print(f"Warning: No surface file found for stage '{STAGE}'. Skipping surface plot.")
    print(f"Available surface files in {OUT_DIR}:")
    for f in sorted(OUT_DIR.glob("surf_*")):
        print(f"  {f.name}")

# === Layout ===
fig.update_layout(
    title=f"Stellarator Coils & Plasma Surface ({STAGE})",
    scene=dict(
        xaxis_title="X [m]",
        yaxis_title="Y [m]",
        zaxis_title="Z [m]",
        aspectmode="data",
        bgcolor="rgb(20, 20, 20)",
    ),
    legend=dict(x=0.01, y=0.99),
    width=1100,
    height=850,
    paper_bgcolor="rgb(30, 30, 30)",
    font=dict(color="white"),
)

fig.show()